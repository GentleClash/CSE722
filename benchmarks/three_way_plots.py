"""
Three-Way Comparison Plots
Generates visual comparisons between Classical, Heuristic, and RL methods.

This script reads the detailed results generated by `run_all_three.py` and produces
a suite of plots to visualize the performance differences across multiple metrics.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os


def load_results():
    """
    Load the detailed result CSVs for all three methods.

    Returns:
        Tuple of DataFrames: (classical, heuristic, rl)
    """
    try:
        c = pd.read_csv('results/classical_detailed.csv')
        h = pd.read_csv('results/heuristic_detailed.csv')
        rl = pd.read_csv('results/rl_detailed.csv')
        return c, h, rl
    except FileNotFoundError:
        print("Error: Result files not found. Run benchmarks/run_all_three.py first.")
        return None, None, None


def plot_cost_comparison(c, h, rl):
    """
    Plot cumulative cost comparison.

    Visualizes how the total cost accumulates over time for each method.
    Lower curves indicate better economic performance.
    """
    plt.figure(figsize=(12, 6))

    # Calculate cumulative costs
    plt.plot(c['total_cost'].cumsum(),
             label='Classical (Optimal)', linewidth=2)
    plt.plot(h['total_cost'].cumsum(), label='Heuristic (Baseline)',
             linewidth=2, linestyle='--')
    plt.plot(rl['total_cost'].cumsum(), label='RL Agent', linewidth=2)

    plt.title('Cumulative Cost Comparison', fontsize=14)
    plt.xlabel('Timestep (Hours)', fontsize=12)
    plt.ylabel('Cumulative Cost ($)', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True, alpha=0.3)

    plt.savefig('results/visualizations/three_way_cost.png', dpi=300)
    print("Saved cost comparison plot")


def plot_balance_error(c, h, rl):
    """
    Plot power balance error distribution.

    Uses a boxplot to show the spread of supply-demand mismatches.
    Closer to zero is better.
    """
    plt.figure(figsize=(10, 6))

    # Prepare data for boxplot
    data = pd.DataFrame({
        'Classical': (c['total_generation'] - c['net_load']).abs(),
        'Heuristic': h['balance_error'],
        'RL Agent': rl['balance_error']
    })

    sns.boxplot(data=data)
    plt.yscale('log')  # Log scale to see small errors
    plt.title('Power Balance Error Distribution (Log Scale)', fontsize=14)
    plt.ylabel('Absolute Error (MW)', fontsize=12)
    plt.grid(True, alpha=0.3)

    plt.savefig('results/visualizations/three_way_balance.png', dpi=300)
    print("Saved balance error plot")


def plot_dispatch_stack(df, method_name, filename):
    """
    Create a stacked area chart of generator dispatch.

    Shows how the load is shared among different generators over time.

    Args:
        df: Results DataFrame containing 'gen_X_power' columns.
        method_name: Name of the method for the title.
        filename: Output filename.
    """
    plt.figure(figsize=(15, 6))

    # Extract generator columns
    gen_cols = [c for c in df.columns if 'gen_' in c and '_power' in c]

    # Plot stacked area
    plt.stackplot(range(len(df)),
                  [df[c] for c in gen_cols],
                  labels=[f'Gen {i+1}' for i in range(len(gen_cols))],
                  alpha=0.8)

    plt.plot(df['net_load'], 'k--', label='Net Load', linewidth=1.5)

    plt.title(f'Generator Dispatch Schedule - {method_name}', fontsize=14)
    plt.xlabel('Timestep', fontsize=12)
    plt.ylabel('Power Output (MW)', fontsize=12)
    plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
    plt.margins(0, 0)

    plt.tight_layout()
    plt.savefig(f'results/visualizations/{filename}', dpi=300)
    print(f"Saved dispatch plot for {method_name}")


def main():
    """
    Main execution function.

    Loads results and generates all comparison plots.
    """
    # Create output directory
    os.makedirs('results/visualizations', exist_ok=True)

    # Load data
    c, h, rl = load_results()
    if c is None or h is None or rl is None:
        return

    # Generate plots
    plot_cost_comparison(c, h, rl)
    plot_balance_error(c, h, rl)

    # Generate dispatch stacks for a subset of time (first 100 steps) to make it readable
    subset = 100
    plot_dispatch_stack(
        c.iloc[:subset], 'Classical Optimization', 'dispatch_classical.png')
    plot_dispatch_stack(
        h.iloc[:subset], 'Heuristic Dispatch', 'dispatch_heuristic.png')
    plot_dispatch_stack(rl.iloc[:subset], 'RL Agent', 'dispatch_rl.png')

    print("\nAll plots generated in results/visualizations/")


if __name__ == "__main__":
    main()
